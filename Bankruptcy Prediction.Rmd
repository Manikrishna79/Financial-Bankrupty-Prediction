---
title: "Financial Analytics"
output: pdf_document
---

#Load the necessary packages 

```{r message=FALSE, warning=FALSE}
rm(list=ls())
require(PortfolioAnalytics)
require(ggplot2)
require(RCurl)
require(fPortfolio)
require(quantmod)
require(caTools)
require(PerformanceAnalytics)
require(crayon)
require(ggthemes)
require(bitops)
require(XML)
require(xts)
require(zoo)
require(knitr)
require(latexpdf)
require(tseries)
require(ROI)
require(quadprog)
require(ROI.plugin.quadprog)
require(ROI.plugin.glpk)
require(ROI.plugin.symphony)


```

Invoke portfolio.r file to access the built in functions in the file

```{r}
source("https://faculty.washington.edu/ezivot/econ424/portfolio.r")
```

To supress warning messages

```{r}
getSymbols.yahoo = FALSE
```

The 10 stocks are

1)Tech Mahindra
2)SBI
3)Apollo Hospitals
4)Reliance
5)Larsen & Toubro
6)CIPLA
7)ITC
8)ONGC
9)DLF
10)AIRTEL


```{r}
#SBI
SBI <- get.hist.quote(instrument = "SBIN.NS", start = "2007-07-01",
                      end = "2018-07-31", quote = "AdjClose",
                      provider = "yahoo", origin = "1970-01-01",
                      compression = "m", retclass = "zoo")
nrow(SBI)
SBI=na.omit(SBI)
nrow(SBI)

#Tech Mahindra
Tech <- get.hist.quote(instrument = "TECHM.NS", start = "2007-07-01",
                       end = "2018-07-31", quote = "AdjClose",
                       provider = "yahoo", origin = "1970-01-01",
                       compression = "m", retclass = "zoo")
nrow(Tech)
Tech <- na.omit(Tech)
nrow(Tech)

#Apollo Hospitals
Apollo <- get.hist.quote(instrument="APOLLOHOSP.NS", start = "2007-07-01",
                         end = "2018-07-31", quote = "AdjClose",
                         provider = "yahoo", origin = "1970-01-01",
                         compression = "m", retclass = "zoo")
nrow(Apollo)
Apollo <- na.omit(Apollo)
nrow(Apollo)

#Reliance
Reliance <- get.hist.quote(instrument = "RELIANCE.NS", start = "2007-07-01",
                           end = "2018-07-31", quote = "AdjClose",
                           provider = "yahoo", origin = "1970-01-01",
                           compression = "m", retclass = "zoo")
nrow(Reliance)
Reliance <- na.omit(Reliance) 
nrow(Reliance)

#Larsen & Toubro
Larsen <- get.hist.quote(instrument = "LT.NS", start = "2007-07-01",
                         end = "2018-07-31", quote = "AdjClose",
                         provider = "yahoo", origin = "1970-01-01",
                         compression = "m", retclass = "zoo")
nrow(Larsen)
Larsen <- na.omit(Larsen)
nrow(Larsen)

#CIPLA
CIPLA <- get.hist.quote(instrument = "CIPLA.NS", start = "2007-07-01",
                        end = "2018-07-31", quote = "AdjClose",
                        provider = "yahoo", origin = "1970-01-01",
                        compression = "m", retclass = "zoo")
start(CIPLA)
CIPLA <- na.omit(CIPLA)
nrow(CIPLA)

#ITC
ITC <- get.hist.quote(instrument = "ITC.NS", start = "2007-07-01",
                      end = "2018-07-31", quote = "AdjClose",
                      provider = "yahoo", origin = "1970-01-01",
                      compression = "m", retclass = "zoo")
start(ITC)
ITC = na.omit(ITC)
nrow(ITC)

#ONGC
ONGC <- get.hist.quote(instrument = "ONGC.NS", start = "2007-07-01",
                     end = "2018-07-31", quote = "AdjClose",
                     provider = "yahoo", origin = "1970-01-01",
                     compression = "m", retclass = "zoo")
nrow(ONGC)
AXIS=na.omit(ONGC)
nrow(ONGC)


#DLF
DLF <- get.hist.quote(instrument = "DLF.NS", start = "2007-07-01",
                     end = "2018-07-31", quote = "AdjClose",
                     provider = "yahoo", origin = "1970-01-01",
                     compression = "m", retclass = "zoo")
nrow(DLF)
DLF=na.omit(DLF)
nrow(DLF)

#AIRTEL
AIRTEL <- get.hist.quote(instrument = "BHARTIARTL.NS", start = "2007-07-01",
                     end = "2018-07-31", quote = "AdjClose",
                     provider = "yahoo", origin = "1970-01-01",
                     compression = "m", retclass = "zoo")
nrow(AIRTEL)
AIRTEL=na.omit(AIRTEL)
nrow(AIRTEL)
```

##Creating Portfolio.Names Using the merge() function to combine 10 Assets.

Merging all the stock prices
```{r}
Portfolio.Names <- c("Larsen","SBI","Tech","Cipla","Apollo","ITC","Reliance","ONGC","AIRTEL","DLF")
Portfolio.Names=na.omit(Portfolio.Names)


#MERGING ALL THE STOCK PRICES
Portfolio<-merge(Larsen,SBI,Reliance,Tech,CIPLA,Apollo,ITC,ONGC,AIRTEL,DLF)
tail(Portfolio,10)

names(Portfolio) <- Portfolio.Names
head(Portfolio)
```

## Calculating returns for the portfolio.
## Use Return.calculate for calculating returns from prices

```{r}
#CALCULATING THE RETURNS FOR THE PORTFOLIO
Portfolio.Returns = Return.calculate(Portfolio, method="simple")
Portfolio.Returns = na.omit(Portfolio.Returns)

head(Portfolio.Returns)
nrow(Portfolio.Returns)

#Define column names
names(Portfolio.Returns) <- Portfolio.Names
```


```{r}
#Create portfolio specification object
pspec <- portfolio.spec(assets = Portfolio.Names)

#FUll Invesment Constraint
FI_Constr <- weight_sum_constraint(min_sum = 1, max_sum = 1)

#Long Only Constraint
LO_Constr <- box_constraint(assets = pspec$assets, min=0, max=1)

#Target Mean Return Constraint
TargetReturn_Constr <- return_constraint(return_target = 0.015)

#Risk Objective
minrisk_obj <- portfolio_risk_objective(name = "var")
```

```{r}
#GLobal Minimum Portfolio
opt_base <- optimize.portfolio(R=Portfolio.Returns, portfolio=pspec,
                                 constraints=list(FI_Constr),
                                 objectives=list(minrisk_obj),
                                 optimize_method="ROI")

#Calculate Global Minimum Portfolio Returns
base_returns <- Return.portfolio(Portfolio.Returns, extractWeights(opt_base))
colnames(base_returns) <- "Global Min"
```
####Global Min Portfolio BackTesting

```{r}
#Run the optimisation with periodic balancing
bt_opt_base <- optimize.portfolio.rebalancing(R = Portfolio.Returns, portfolio = pspec, constraints = list(FI_Constr), objectives = list(minrisk_obj), rebalance_on = "months",optimize_method = "ROI", training_period = 60, rolling_window = 60)

backtesting_base_returns <- Return.portfolio(Portfolio.Returns, extractWeights(bt_opt_base))
colnames(backtesting_base_returns) <- "BackTesting_GlobalMin"

#Annualised Performance
table.AnnualizedReturns(cbind(base_returns, backtesting_base_returns))
```


```{r}

#Chart the optimal weights for the back tested base portfolio
chart.Weights(bt_opt_base, colorset = tim12equal)
```
###Box constraint - separate caps for individual assets
```{r}
box_Constr <- box_constraint(assets = pspec$assets,
                              min=c(0, 0.02, 0.02, 0.04, 0.16, 0.32, 0.26, 0.11, 0.04, 0),
                              max=c(0, 0.7, 0.8, 0.6, 0.5, 0.75, 0.8, 0.7, 0.8, 0))

box_opt_minvar <- optimize.portfolio(R=Portfolio.Returns, portfolio=pspec,
                                      constraints = list(FI_Constr, LO_Constr,
                                                         TargetReturn_Constr, box_Constr),
                                      objectives = list(minrisk_obj),
                                      optimize_method = "ROI", trace=TRUE)

box_opt_minvar
```
```{r}
#Calculate returns under specified constraints and objectives
box_minvar_returns <- Return.portfolio(Portfolio.Returns, extractWeights(box_opt_minvar))
colnames(box_minvar_returns) <- "Box Constraint"

#Run the optimisation with periodic balancing
bt_box_opt_minvar <- optimize.portfolio.rebalancing(R = Portfolio.Returns, portfolio = pspec,
                                             constraints = list(FI_Constr,LO_Constr,
                                                                TargetReturn_Constr, box_Constr),
                                             objectives = list(minrisk_obj),
                                             rebalance_on = "months", optimize_method = "ROI",
                                             training_period = 60, rolling_window = 60)

bt_box_minvar_returns <- Return.portfolio(Portfolio.Returns, extractWeights(bt_box_opt_minvar))

backtesting_box_returns <- Return.portfolio(Portfolio.Returns, extractWeights(bt_box_opt_minvar))
colnames(backtesting_box_returns) <- "BackTesting_Box"

#Annualized Performance
table.AnnualizedReturns(cbind(box_minvar_returns, backtesting_box_returns))

table.AnnualizedReturns(cbind(base_returns, backtesting_base_returns,box_minvar_returns, backtesting_box_returns))
```


```{r}
#For Pairs Trading Strategy
require(corrplot)
cor(Portfolio)
```


```{r}
corrplot(cor(Portfolio), method = "circle")
```

```{r}

# to disable scientific notations in R
options(scipen=999)

# CORRELATION BASED PAIRS TRADING
stock1 <- "SBIN.NS"
stock2 <- "APOLLOHOSP.NS"

getSymbols(stock1, src = "yahoo")
getSymbols(stock2, src = "yahoo")

stock1 <- SBIN.NS
stock2 <- APOLLOHOSP.NS

(head(stock1))
(head(stock2))
stock1 <- stock1[, grep("Adjusted", colnames(stock1))]
stock2 <- stock2[, grep("Adjusted", colnames(stock2))]

cut_off_date <- as.Date("2012-01-01")
stock1 <- stock1[index(stock1) >= cut_off_date]
stock2 <- stock2[index(stock2) >= cut_off_date]
dim(stock2[is.na(stock2),])
dim(stock2[is.na(stock2),])
stock1 <- na.locf(stock1)
stock2 <- na.locf(stock2)
ret_stock1 <- Delt(stock1)
ret_stock2 <- Delt(stock2)
data <- data.frame(matrix(NA, dim(ret_stock1)[1], 2))
data[, 1] <- ret_stock1
data[, 2] <- ret_stock2
data <- xts(data, index(ret_stock1))
head(data)
#Now since it's a correlation based strategy, we'll calculate 100 period rolling correlation between the stocks using our function, that we'll build,correlation. Also, let's plot the rolling correlation to visualize it

correlation <- function(x) {
  result <- cor(x[, 1], x[, 2])
  return(result)
}
corr <- rollapply(data, 100, correlation, by.column = FALSE)
plot(corr)
# So, we can see that whenever the rolling correlation weakens, it gets better in some time. And our complete strategy is based on this mean reversion behavior of correlation between our pair.The strategy is to short the outperforming stock and go long on the underperforming stock whenever the temporary correlation weakens which means one stock going up and another going down. And to calculate the trade size, we would need to calculatehedge_ratio which is simply the ratio of the closing price of ICICIBANK to SBIN. So whenever we want to go short on spread we'll short 1 unit of ICICI and go long on hedge ratio times units of SBIN


hedge_ratio <- stock1/stock2

#Now, it's time to generate trading signals and for that, we need to define our trading logic. So, in this example, we'll go long on the spread when the hedge ratio goes below its n_period  rolling mean by n times of its rolling standard deviation and vice versa. Please note that both n_period and n can be changed as per your selection of stocks. Let's generate trading signals

n_period <- 14
roll_me <- rollapply(hedge_ratio, n_period, mean)
roll_std <- rollapply(hedge_ratio, n_period, sd)

n <- 1
roll_ub <- roll_me + roll_std*n
roll_lb <- roll_me - roll_std *n

plot(cbind(hedge_ratio, roll_ub, roll_lb))
signal <- NULL
signal <- ifelse(
  hedge_ratio > roll_ub, -1, ifelse(
    hedge_ratio < roll_lb, 1, 0
  )
)
#Also, now we know that we will act (BUY or SELL) once we get the signal our execution will be on a delay of 1 period, So, let's apply lag of period one to our signa

signal <- lag(signal, 1)
spread_return <- ret_stock1 - ret_stock2*hedge_ratio
trade_return <- spread_return*signal
charts.PerformanceSummary(trade_return)
print(paste0("Cumulative Returns -- ", Return.cumulative(trade_return)))
print(paste0("Annualized Returns -- ", Return.annualized(trade_return)))
print(paste0("Maximum Drawdown -- ", maxDrawdown(trade_return)))
print(paste0("Sharpe Ratio -- ", SharpeRatio(as.ts(trade_return), Rf = 0, p = 0.95, FUN = "StdDev")))

```


